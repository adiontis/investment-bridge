investment-bridge/
├── package.json
├── server.js
├── database.js
├── routes/
│ ├── auth.js
│ ├── businesses.js
│ ├── investments.js
│ ├── payouts.js
│ └── users.js
├── middleware/
│ ├── auth.js
│ ├── validation.js
│ └── rateLimit.js
├── public/
│ ├── index.html
│ ├── css/
│ │ └── styles.css
│ ├── js/
│ │ ├── app.js
│ │ ├── auth.js
│ │ ├── dashboard.js
│ │ ├── business.js
│ │ └── investment.js
│ └── assets/
├── utils/
│ ├── progressionEngine.js
│ ├── riskRating.js
│ ├── escrow.js
│ └── notifications.js
└── README.md
```

## Core Files

### package.json

```json
{
"name": "investment-bridge",
"version": "1.0.0",
"description": "Investment bridge platform connecting startups with everyday investors",
"main": "server.js",
"scripts": {
"start": "node server.js",
"dev": "nodemon server.js",
"migrate": "node database.js"
},
"dependencies": {
"express": "^4.18.2",
"bcryptjs": "^2.4.3",
"jsonwebtoken": "^9.0.2",
"sqlite3": "^5.1.6",
"cors": "^2.8.5",
"helmet": "^7.0.0",
"express-rate-limit": "^6.8.1",
"joi": "^17.9.2",
"multer": "^1.4.5-lts.1",
"uuid": "^9.0.0",
"node-cron": "^3.0.2"
},
"devDependencies": {
"nodemon": "^3.0.1"
},
"engines": {
"node": ">=16.0.0"
}
}
```

### server.js

```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const path = require('path');
const cron = require('node-cron');

const { initDatabase } = require('./database');
const authRoutes = require('./routes/auth');
const businessRoutes = require('./routes/businesses');
const investmentRoutes = require('./routes/investments');
const payoutRoutes = require('./routes/payouts');
const userRoutes = require('./routes/users');
const { processWeeklyPayouts } = require('./utils/escrow');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet({
contentSecurityPolicy: {
directives: {
defaultSrc: ["'self'"],
styleSrc: ["'self'", "'unsafe-inline'"],
scriptSrc: ["'self'", "'unsafe-inline'"],
imgSrc: ["'self'", "data:", "https:"],
},
},
}));
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(express.static('public'));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/businesses', businessRoutes);
app.use('/api/investments', investmentRoutes);
app.use('/api/payouts', payoutRoutes);
app.use('/api/users', userRoutes);

// Serve main app
app.get('*', (req, res) => {
res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Weekly payout job (Wednesdays at 12:00 PM EST)
cron.schedule('0 12 * * 3', () => {
console.log('Running weekly payout processing...');
processWeeklyPayouts();
}, {
timezone: "America/New_York"
});

// Initialize database and start server
initDatabase().then(() => {
app.listen(PORT, () => {
console.log(`Investment Bridge server running on port ${PORT}`);
console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
});
}).catch(err => {
console.error('Failed to initialize database:', err);
process.exit(1);
});

module.exports = app;
```

### database.js

```javascript
const sqlite3 = require('sqlite3').verbose();
const path = require('path');

const dbPath = process.env.NODE_ENV === 'production'
? '/data/investment_bridge.db'
: path.join(__dirname, 'investment_bridge.db');

const db = new sqlite3.Database(dbPath);

const initDatabase = () => {
return new Promise((resolve, reject) => {
db.serialize(() => {
// Users table
db.run(`
CREATE TABLE IF NOT EXISTS users (
id INTEGER PRIMARY KEY AUTOINCREMENT,
email TEXT UNIQUE NOT NULL,
password_hash TEXT NOT NULL,
first_name TEXT NOT NULL,
last_name TEXT NOT NULL,
phone TEXT,
kyc_status TEXT DEFAULT 'pending',
max_spend_limit REAL DEFAULT 35.00,
current_tier INTEGER DEFAULT 1,
cooldown_until DATETIME,
created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
)
`);

// Businesses table
db.run(`
CREATE TABLE IF NOT EXISTS businesses (
id INTEGER PRIMARY KEY AUTOINCREMENT,
name TEXT NOT NULL,
description TEXT,
owner_id INTEGER,
llc_verified BOOLEAN DEFAULT false,
bank_verified BOOLEAN DEFAULT false,
monthly_revenue REAL DEFAULT 0,
risk_rating TEXT DEFAULT 'C',
risk_score INTEGER DEFAULT 70,
video_url TEXT,
verification_status TEXT DEFAULT 'pending',
created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
FOREIGN KEY (owner_id) REFERENCES users (id)
)
`);

// Investments table
db.run(`
CREATE TABLE IF NOT EXISTS investments (
id INTEGER PRIMARY KEY AUTOINCREMENT,
user_id INTEGER NOT NULL,
business_id INTEGER NOT NULL,
amount REAL NOT NULL,
fee_amount REAL DEFAULT 0,
status TEXT DEFAULT 'pending_escrow',
risk_percentage REAL,
growth_increase REAL DEFAULT 0,
expected_return REAL,
payout_date DATE,
created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
FOREIGN KEY (user_id) REFERENCES users (id),
FOREIGN KEY (business_id) REFERENCES businesses (id)
)
`);

// Payouts table
db.run(`
CREATE TABLE IF NOT EXISTS payouts (
id INTEGER PRIMARY KEY AUTOINCREMENT,
investment_id INTEGER NOT NULL,
user_id INTEGER NOT NULL,
amount REAL NOT NULL,
fee_amount REAL DEFAULT 0,
status TEXT DEFAULT 'pending',
processed_at DATETIME,
completed_at DATETIME,
created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
FOREIGN KEY (investment_id) REFERENCES investments (id),
FOREIGN KEY (user_id) REFERENCES users (id)
)
`);

// Business ratings table
db.run(`
CREATE TABLE IF NOT EXISTS business_ratings (
id INTEGER PRIMARY KEY AUTOINCREMENT,
business_id INTEGER NOT NULL,
user_id INTEGER NOT NULL,
rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
comment TEXT,
created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
FOREIGN KEY (business_id) REFERENCES businesses (id),
FOREIGN KEY (user_id) REFERENCES users (id)
)
`);

// Insert sample data for development
if (process.env.NODE_ENV !== 'production') {
// Sample businesses
db.run(`
INSERT OR IGNORE INTO businesses (
id, name, description, monthly_revenue, risk_rating, risk_score,
llc_verified, bank_verified, verification_status, video_url
) VALUES
(1, 'EcoTech Solutions', 'Sustainable technology for modern homes', 15000, 'A', 92, 1, 1, 'verified', 'https://example.com/video1'),
(2, 'Urban Farming Co', 'Vertical farming solutions for cities', 8500, 'B', 85, 1, 1, 'verified', 'https://example.com/video2'),
(3, 'Digital Health Plus', 'AI-powered health monitoring', 25000, 'A', 95, 1, 1, 'verified', 'https://example.com/video3'),
(4, 'Green Energy Storage', 'Battery solutions for renewable energy', 12000, 'B', 78, 1, 1, 'verified', 'https://example.com/video4'),
(5, 'Smart Logistics Hub', 'Last-mile delivery optimization', 6000, 'C', 72, 1, 1, 'verified', 'https://example.com/video5')
`);
}

resolve();
});
});
};

module.exports = { db, initDatabase };
```

### routes/auth.js

```javascript
const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { db } = require('../database');
const { validateRegistration, validateLogin } = require('../middleware/validation');
const rateLimit = require('../middleware/rateLimit');

const router = express.Router();
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';

// Register
router.post('/register', rateLimit.auth, validateRegistration, async (req, res) => {
try {
const { email, password, firstName, lastName, phone } = req.body;

// Check if user exists
db.get('SELECT id FROM users WHERE email = ?', [email], async (err, row) => {
if (err) {
return res.status(500).json({ error: 'Database error' });
}

if (row) {
return res.status(400).json({ error: 'Email already registered' });
}

// Hash password
const passwordHash = await bcrypt.hash(password, 10);

// Insert user
db.run(
`INSERT INTO users (email, password_hash, first_name, last_name, phone)
VALUES (?, ?, ?, ?, ?)`,
[email, passwordHash, firstName, lastName, phone],
function(err) {
if (err) {
return res.status(500).json({ error: 'Failed to create user' });
}

const token = jwt.sign({ userId: this.lastID }, JWT_SECRET, { expiresIn: '24h' });

res.status(201).json({
message: 'Registration successful',
token,
user: {
id: this.lastID,
email,
firstName,
lastName,
maxSpendLimit: 35.00,
currentTier: 1
}
});
}
);
});
} catch (error) {
res.status(500).json({ error: 'Server error' });
}
});

// Login
router.post('/login', rateLimit.auth, validateLogin, async (req, res) => {
try {
const { email, password } = req.body;

db.get(
'SELECT * FROM users WHERE email = ?',
[email],
async (err, user) => {
if (err) {
return res.status(500).json({ error: 'Database error' });
}

if (!user || !await bcrypt.compare(password, user.password_hash)) {
return res.status(401).json({ error: 'Invalid credentials' });
}

const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '24h' });

res.json({
message: 'Login successful',
token,
user: {
id: user.id,
email: user.email,
firstName: user.first_name,
lastName: user.last_name,
maxSpendLimit: user.max_spend_limit,
currentTier: user.current_tier,
kycStatus: user.kyc_status,
cooldownUntil: user.cooldown_until
}
});
}
);
} catch (error) {
res.status(500).json({ error: 'Server error' });
}
});

module.exports = router;
```

### routes/businesses.js

```javascript
const express = require('express');
const { db } = require('../database');
const auth = require('../middleware/auth');

const router = express.Router();

// Get all verified businesses
router.get('/', (req, res) => {
const query = `
SELECT b.*,
ROUND(AVG(br.rating), 1) as avg_rating,
COUNT(br.id) as rating_count,
ROUND(b.monthly_revenue * 0.3) as max_investment_per_user
FROM businesses b
LEFT JOIN business_ratings br ON b.id = br.business_id
WHERE b.verification_status = 'verified'
GROUP BY b.id
ORDER BY b.risk_score DESC, b.monthly_revenue DESC
`;

db.all(query, [], (err, businesses) => {
if (err) {
return res.status(500).json({ error: 'Failed to fetch businesses' });
}

res.json({ businesses });
});
});

// Get single business with detailed info
router.get('/:id', (req, res) => {
const businessId = req.params.id;

const businessQuery = `
SELECT b.*,
ROUND(AVG(br.rating), 1) as avg_rating,
COUNT(br.id) as rating_count,
ROUND(b.monthly_revenue * 0.3) as max_investment_per_user
FROM businesses b
LEFT JOIN business_ratings br ON b.id = br.business_id
WHERE b.id = ? AND b.verification_status = 'verified'
GROUP BY b.id
`;

db.get(businessQuery, [businessId], (err, business) => {
if (err) {
return res.status(500).json({ error: 'Database error' });
}

if (!business) {
return res.status(404).json({ error: 'Business not found' });
}

// Get recent ratings and comments
const ratingsQuery = `
SELECT br.*, u.first_name, u.last_name
FROM business_ratings br
JOIN users u ON br.user_id = u.id
WHERE br.business_id = ?
ORDER BY br.created_at DESC
LIMIT 10
`;

db.all(ratingsQuery, [businessId], (err, ratings) => {
if (err) {
return res.status(500).json({ error: 'Failed to fetch ratings' });
}

// Get investment statistics
const statsQuery = `
SELECT
COUNT(*) as total_investments,
COALESCE(SUM(amount), 0) as total_invested,
COALESCE(AVG(amount), 0) as avg_investment
FROM investments
WHERE business_id = ?
`;

db.get(statsQuery, [businessId], (err, stats) => {
if (err) {
return res.status(500).json({ error: 'Failed to fetch stats' });
}

res.json({
business: {
...business,
ratings,
stats
}
});
});
});
});
});

// Add rating/comment to business
router.post('/:id/rate', auth, (req, res) => {
const { rating, comment } = req.body;
const businessId = req.params.id;
const userId = req.user.userId;

if (!rating || rating < 1 || rating > 5) {
return res.status(400).json({ error: 'Rating must be between 1 and 5' });
}

// Check if user has invested in this business
db.get(
'SELECT id FROM investments WHERE user_id = ? AND business_id = ?',
[userId, businessId],
(err, investment) => {
if (err) {
return res.status(500).json({ error: 'Database error' });
}

if (!investment) {
return res.status(403).json({ error: 'You must invest before rating' });
}

// Insert or update rating
db.run(
`INSERT OR REPLACE INTO business_ratings
(business_id, user_id, rating, comment)
VALUES (?, ?, ?, ?)`,
[businessId, userId, rating, comment],
function(err) {
if (err) {
return res.status(500).json({ error: 'Failed to save rating' });
}

res.json({ message: 'Rating saved successfully' });
}
);
}
);
});

module.exports = router;
```

### routes/investments.js

```javascript
const express = require('express');
const { db } = require('../database');
const auth = require('../middleware/auth');
const { calculateProgression } = require('../utils/progressionEngine');
const { validateInvestment } = require('../middleware/validation');

const router = express.Router();

// Make investment
router.post('/', auth, validateInvestment, async (req, res) => {
try {
const { businessId, amount } = req.body;
const userId = req.user.userId;

// Get user details
db.get('SELECT * FROM users WHERE id = ?', [userId], (err, user) => {
if (err) {
return res.status(500).json({ error: 'Database error' });
}

// Check cooldown
if (user.cooldown_until && new Date() < new Date(user.cooldown_until)) {
const cooldownEnd = new Date(user.cooldown_until);
const hoursLeft = Math.ceil((cooldownEnd - new Date()) / (1000 * 60 * 60));
return res.status(429).json({
error: 'Account in recovery period',
cooldownHours: hoursLeft
});
}

// Check spending limit
if (amount > user.max_spend_limit) {
return res.status(400).json({
error: 'Investment exceeds your current limit',
maxLimit: user.max_spend_limit
});
}

// Get business details
db.get('SELECT * FROM businesses WHERE id = ? AND verification_status = "verified"',
[businessId], (err, business) => {
if (err) {
return res.status(500).json({ error: 'Database error' });
}

if (!business) {
return res.status(404).json({ error: 'Business not found or not verified' });
}

// Check per-business investment limit (30% of monthly revenue)
const maxPerBusiness = business.monthly_revenue * 0.3;
if (amount > maxPerBusiness) {
return res.status(400).json({
error: 'Investment exceeds maximum allowed for this business',
maxAllowed: maxPerBusiness
});
}

// Calculate progression
const progression = calculateProgression(user, amount);
const riskPercentage = (amount / user.max_spend_limit) * 100;

// Calculate fees (2% platform fee)
const feeAmount = amount * 0.02;
const totalCharge = amount + feeAmount;

// Expected return (example: 5-15% based on risk rating)
const returnMultipliers = { 'A': 1.08, 'B': 1.12, 'C': 1.15, 'D': 1.18, 'F': 1.20 };
const expectedReturn = amount * (returnMultipliers[business.risk_rating] || 1.10);

// Insert investment
db.run(
`INSERT INTO investments
(user_id, business_id, amount, fee_amount, risk_percentage,
growth_increase, expected_return, payout_date)
VALUES (?, ?, ?, ?, ?, ?, ?, date('now', '+7 days'))`,
[userId, businessId, amount, feeAmount, riskPercentage,
progression.growthIncrease, expectedReturn],
function(err) {
if (err) {
return res.status(500).json({ error: 'Failed to create investment' });
}

// Update user's spending limit and cooldown
const newCooldown = progression.cooldownHours > 0
? new Date(Date.now() + progression.cooldownHours * 60 * 60 * 1000)
: null;

db.run(
`UPDATE users
SET max_spend_limit = ?, current_tier = ?, cooldown_until = ?,
updated_at = CURRENT_TIMESTAMP
WHERE id = ?`,
[progression.newMaxLimit, progression.newTier, newCooldown, userId],
(err) => {
if (err) {
return res.status(500).json({ error: 'Failed to update user progress' });
}

res.json({
message: 'Investment created successfully',
investment: {
id: this.lastID,
amount,
feeAmount,
totalCharge,
expectedReturn,
riskPercentage,
payoutDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
},
progression: {
newMaxLimit: progression.newMaxLimit,
newTier: progression.newTier,
growthIncrease: progression.growthIncrease,
cooldownHours: progression.cooldownHours
}
});
}
);
}
);
});
});
} catch (error) {
res.status(500).json({ error: 'Server error' });
}
});

// Get user's investments
router.get('/portfolio', auth, (req, res) => {
const userId = req.user.userId;

const query = `
SELECT i.*, b.name as business_name, b.risk_rating,
p.status as payout_status, p.amount as payout_amount,
p.processed_at, p.completed_at
FROM investments i
JOIN businesses b ON i.business_id = b.id
LEFT JOIN payouts p ON i.id = p.investment_id
WHERE i.user_id = ?
ORDER BY i.created_at DESC
`;

db.all(query, [userId], (err, investments) => {
if (err) {
return res.status(500).json({ error: 'Failed to fetch investments' });
}

// Group by status for easier frontend handling
const portfolio = {
active: investments.filter(inv => inv.status === 'pending_escrow'),
released: investments.filter(inv => inv.status === 'released'),
processing: investments.filter(inv => inv.status === 'processing'),
completed: investments.filter(inv => inv.status === 'paid'),
total: {
invested: investments.reduce((sum, inv) => sum + inv.amount, 0),
returns: investments.reduce((sum, inv) => sum + (inv.payout_amount || 0), 0),
pending: investments.filter(inv => inv.status === 'pending_escrow').length
}
};

res.json({ portfolio });
});
});

module.exports = router;
```

### routes/users.js

```javascript
const express = require('express');
const { db } = require('../database');
const auth = require('../middleware/auth');

const router = express.Router();

// Get user dashboard data
router.get('/dashboard', auth, (req, res) => {
const userId = req.user.userId;

// Get user info with current stats
db.get('SELECT * FROM users WHERE id = ?', [userId], (err, user) => {
if (err) {
return res.status(500).json({ error: 'Database error' });
}

// Get investment summary
const investmentQuery = `
SELECT
COUNT(*) as total_investments,
COALESCE(SUM(amount), 0) as total_invested,
COUNT(CASE WHEN status = 'pending_escrow' THEN 1 END) as pending_count,
COUNT(CASE WHEN status = 'paid' THEN 1 END) as completed_count
FROM investments
WHERE user_id = ?
`;

db.get(investmentQuery, [userId], (err, investmentStats) => {
if (err) {
return res.status(500).json({ error: 'Failed to fetch investment stats' });
}

// Get recent investments
const recentQuery = `
SELECT i.*, b.name as business_name, b.risk_rating
FROM investments i
JOIN businesses b ON i.business_id = b.id
WHERE i.user_id = ?
ORDER BY i.created_at DESC
LIMIT 5
`;

db.all(recentQuery, [userId], (err, recentInvestments) => {
if (err) {
return res.status(500).json({ error: 'Failed to fetch recent investments' });
}

// Calculate tier progress
const tierRanges = [
{ tier: 1, min: 35, max: 250 },
{ tier: 2, min: 250, max: 1000 },
{ tier: 3, min: 1000, max: 2000 },
{ tier: 4, min: 2000, max: 3000 }
];

const currentTierRange = tierRanges.find(t => t.tier === user.current_tier);
const progressPercent = currentTierRange
? ((user.max_spend_limit - currentTierRange.min) / (currentTierRange.max - currentTierRange.min)) * 100
: 100;

const dashboard = {
user: {
id: user.id,
email: user.email,
firstName: user.first_name,
lastName: user.last_name,
maxSpendLimit: user.max_spend_limit,
currentTier: user.current_tier,
kycStatus: user.kyc_status,
cooldownUntil: user.cooldown_until
},
progress: {
currentLimit: user.max_spend_limit,
currentTier: user.current_tier,
progressPercent: Math.min(progressPercent, 100),
nextTierAt: currentTierRange ? currentTierRange.max : 3000,
remainingToNextTier: currentTierRange
? Math.max(0, currentTierRange.max - user.max_spend_limit)
: 0
},
stats: investmentStats,
recentInvestments,
cooldownInfo: {
inCooldown: user.cooldown_until && new Date() < new Date(user.cooldown_until),
hoursRemaining: user.cooldown_until
? Math.max(0, Math.ceil((new Date(user.cooldown_until) - new Date()) / (1000 * 60 * 60)))
: 0
}
};

res.json({ dashboard });
});
});
});
});

// Update KYC status (simplified - in production would integrate with ID verification service)
router.post('/kyc', auth, (req, res) => {
const { documentType, documentNumber } = req.body;
const userId = req.user.userId;

// Simplified KYC - in production, integrate with Jumio/Persona/etc
if (!documentType || !documentNumber) {
return res.status(400).json({ error: 'Document type and number required' });
}

db.run(
'UPDATE users SET kyc_status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
['verified', userId],
function(err) {
if (err) {
return res.status(500).json({ error: 'Failed to update KYC status' });
}

res.json({ message: 'KYC verification completed successfully' });
}
);
});

module.exports = router;
```

### utils/progressionEngine.js

```javascript
// Risk-Reward Progression System Implementation

const TIER_CONFIG = {
1: { min: 35, max: 250, baseGrowthRate: 0.50 },
2: { min: 250, max: 1000, baseGrowthRate: 0.75 },
3: { min: 1000, max: 2000, baseGrowthRate: 1.00 },
4: { min: 2000, max: 3000, baseGrowthRate: 1.50 }
};

const RISK_MULTIPLIERS = {
low: { threshold: 0.25, multiplier: 1.0, cooldownHours: 0 },
medium: { threshold: 0.50, multiplier: 1.5, cooldownHours: 0 },
high: { threshold: 0.99, multiplier: 2.0, cooldownHours: 12 },
allIn: { threshold: 1.00, multiplier: 3.0, cooldownHours: 24 }
};

const MAX_INCREASE_PER_TRANSACTION = 500;
const MAX_SPEND_LIMIT = 3000;

function calculateProgression(user, investmentAmount) {
// 1. Minimum investment check
if (investmentAmount < 5) {
throw new Error('Minimum investment is $5');
}

// 2. Determine current tier
const currentTier = getCurrentTier(user.max_spend_limit);
const tierConfig = TIER_CONFIG[currentTier];

if (!tierConfig) {
throw new Error('Invalid tier configuration');
}

// 3. Calculate risk percentage and get multiplier
const riskPercentage = investmentAmount
```
